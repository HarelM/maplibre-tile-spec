{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Note: This is a live specification that evolves continuously. Features marked as  are under active development and may change in future versions. Stable features are those without experimental tags.</p> <p>The MLT format is mainly inspired by the MVT format, but has been redesigned from the ground up to improve the following areas:</p> <ul> <li>Improved compression ratio - up to 6x on large tiles, based on a column oriented layout with (custom) lightweight encodings</li> <li>Better decoding performance - fast lightweight encodings which can be used in combination with SIMD/vectorization instructions</li> <li>Support for linear referencing and m-values to efficiently support the upcoming next generation source formats such as Overture Maps (GeoParquet)</li> <li>Support 3D coordinates, i.e. elevation</li> <li>Support complex types, including nested properties, lists and maps</li> <li>Improved processing performance: Based on an in-memory format that can be processed efficiently on the CPU and GPU and loaded directly into GPU buffers partially (like polygons in WebGL) or completely (in case of WebGPU compute shader usage) without additional processing</li> </ul>"},{"location":"encodings/","title":"Encoding Algorithms","text":"Encoding Definitions <ul> <li>1. Plain</li> <li>2. Boolean-RLE</li> <li>3. Byte-RLE</li> <li>4. Dictionary Encoding<ul> <li>4.1 String Dictionary Encoding<ul> <li>4.1.1 FSST Dictionary Encoding</li> <li>4.1.2 Shared Dictionary Encoding</li> </ul> </li> <li>4.2 Vertex Dictionary Encoding<ul> <li>4.2.1 Morton Vertex Dictionary Encoding</li> </ul> </li> </ul> </li> <li>5. Integer Encodings<ul> <li>5.1 Logical Level Technique<ul> <li>5.1.1 Delta</li> <li>5.1.2 RLE</li> <li>5.1.3 Combining delta and rle (Delta-RLE)</li> </ul> </li> <li>5.2 Physical Level Technique (Null Suppression)<ul> <li>5.2.1 ZigZag encoding</li> <li>5.2.2 Varint encoding</li> <li>5.2.3 SIMD-FastPFOR</li> </ul> </li> </ul> </li> <li>6. Float encodings<ul> <li>6.1 Adaptive Lossless floating-Point Compression (ALP)</li> </ul> </li> </ul>"},{"location":"encodings/#1-plain","title":"1. Plain","text":"<p>No compression technique is applied on the data. Depending on the data type, the data are stored in the following format:</p> <ul> <li>Boolean: Least-significant bit ordering within bytes</li> <li>Integer: Little-Endian byte order</li> <li>Long: Little-Endian byte order</li> <li>Float: IEEE754 floating-point numbers in Little-Endian byte order</li> <li>Double: IEEE754 floating-point numbers in Little-Endian byte order</li> <li>String: length and data streams</li> </ul>"},{"location":"encodings/#2-boolean-rle","title":"2. Boolean-RLE","text":"<p>This encoding is used for compressing boolean columns. Least-significant bit numbering (bit-endianness) is used as bit order. Have a look at the ORC specification for implementation details.</p>"},{"location":"encodings/#3-byte-rle","title":"3. Byte-RLE","text":"<p>This encoding is used for compressing byte streams such as the <code>GeometryType</code> stream of the Geometry column. Have a look at the ORC specification for implementation details.</p>"},{"location":"encodings/#4-dictionary-encoding","title":"4. Dictionary Encoding","text":"<p>Dictionary encoding is used to compactly represent repeated values and can be applied to <code>String</code> and <code>Geometry</code> columns. In addition to the actual distinct values stored in the <code>dictionary</code> stream, a separate <code>data</code> stream for the indices into the dictionary is used.</p>"},{"location":"encodings/#41-string-dictionary-encoding","title":"4.1 String Dictionary Encoding","text":"<p>The dictionary stream contains distinct UTF-8 encoded string values. The data stream contains the indices for the dictionary encoded as <code>UInt32</code>. A dictionary-encoded nullable string column contains of the following streams and order: <code>Present</code>, <code>Length</code>, <code>Dictionary</code>, <code>Data</code>.</p> <p>All streams can be further compressed by recursively applying lightweight encodings:</p> <ul> <li>Present Stream: Boolean-RLE</li> <li>Length and Data Stream: see Integer encodings</li> <li>Dictionary: see FSST Dictionary</li> </ul>"},{"location":"encodings/#411-fsst-dictionary-encoding","title":"4.1.1 FSST Dictionary Encoding","text":"<p>Dictionary encoding needs fully repeating strings to reduce size. However, the attributes of geospatial data often contains strings which share a common prefix but are not completely equal such as the localized country names. FSST replaces frequently occurring substrings while maintaining support for efficient scans and random look-ups. It is used in MLT to further compress the UTF-8 encoded dictionary values. A FSST Dictionary-encoded nullable string column contains of the following streams and order: <code>Present</code>, <code>SymbolLength</code>, <code>SymbolTable</code>, <code>String Length</code>, <code>Dictionary</code> (Compressed Corpus) For implementation details see the following paper</p> <p>Available implementations:</p> <ul> <li>C++: https://github.com/cwida/fsst</li> <li>Java: Work in Progress</li> <li>Js/WebAssembly decoder: Work in Progress (simple to implement)</li> </ul>"},{"location":"encodings/#412-shared-dictionary-encoding","title":"4.1.2 Shared Dictionary Encoding","text":"<p>A Shared dictionary encoding can be used, to share a common dictionary between the columns. In addition, nested fields can use a shared dictionary encoding, to share a common dictionary between the fields. This can be applied for example on localized values of the name:* columns of an OSM dataset that can be identical across fields. If a shared dictionary encoding is used for nested fields, all fields that use the shared dictionary must be grouped one behind the other in the file and prefixed with the dictionary.</p> <p>Shared dictionary-encoded nullable string columns consists of the following streams and order: <code>Length</code>, <code>Dictionary</code>, <code>Present1</code>, <code>Data1</code>, <code>Present2</code>, <code>Data2</code></p> <p>Shared FSST Dictionary-encoded nullable string columns consists of the following streams and order: <code>SymbolLength</code>, <code>SymbolTable</code>, <code>String Length</code>, <code>Dictionary</code> (Compressed Corpus), <code>Present1</code>, <code>Data1</code>, <code>Present2</code>, <code>Data2</code></p>"},{"location":"encodings/#42-vertex-dictionary-encoding","title":"4.2 Vertex Dictionary Encoding","text":"<p>Uses an additional <code>VertexOffsets</code> stream for storing the indices to the coordinates of the vertices in the <code>VertexBuffer</code> stream. The vertices in the VertexBuffer are sorted on a Hilbert-Curve and delta-encoded in combination with a null suppression technique.</p>"},{"location":"encodings/#421-morton-vertex-dictionary-encoding","title":"4.2.1 Morton Vertex Dictionary Encoding","text":"<p>The coordinates of the <code>VertexBuffer</code> are transformed to a 1D integer using the Morton Code. Then the data are sorted according to the Morton code and further compressed by applying an Integer compression technique.</p>"},{"location":"encodings/#5-integer-encodings","title":"5. Integer Encodings","text":"<p>In general most data in MLT are stored in the form of arrays of integers. Using efficient and fast algorithms for compressing arrays of integers is therefore crucial.</p>"},{"location":"encodings/#51-logical-level-technique","title":"5.1 Logical Level Technique","text":"<p>Integers are encoded based on the two lightweight compression techniques delta and rle as well as a combination of both schemes called delta-rle.</p>"},{"location":"encodings/#511-delta","title":"5.1.1 Delta","text":"<p>Compute the differences between consecutive elements of a sequence e.g. x2 - x1, x3 - x2, ... Is always used in combination with a physical level technique to reduce the number of bits needed to store the delta values.</p>"},{"location":"encodings/#512-rle","title":"5.1.2 RLE","text":"<p>See https://en.wikipedia.org/wiki/Run-length_encoding for a basic explanation All runs and values are stored in two separate buffers. If the values are unsigned integers ZigZag encoding is applied to the values buffer. Both buffers are then further compressed using a null suppression technique.</p>"},{"location":"encodings/#513-combining-delta-and-rle-delta-rle","title":"5.1.3 Combining delta and rle (Delta-RLE)","text":"<p>Delta-compress the values and then apply RLE encoding. This technique is efficient for ascending sequences like <code>id</code>s.</p>"},{"location":"encodings/#52-physical-level-technique-null-suppression","title":"5.2 Physical Level Technique (Null Suppression)","text":""},{"location":"encodings/#521-zigzag-encoding","title":"5.2.1  ZigZag encoding","text":"<p>For encoding unsigned integers, ZigZag encoding is used for both of the following null suppression techniques. ZigZag encoding uses the least significant bit for encoding the sign.</p>"},{"location":"encodings/#522-varint-encoding","title":"5.2.2 Varint encoding","text":"<p>Byte-aligned null suppression technique try to compress an integer using a minimal number of bytes. For implementation details see Protobuf.</p>"},{"location":"encodings/#523-simd-fastpfor","title":"5.2.3 SIMD-FastPFOR","text":"<p>Bit-aligned null suppression technique that compresses an integer using a minimal number of bits by using a patched approach to store exceptions (outliers) in a separate section to keep the overall bit width small.</p> <p>see https://arxiv.org/pdf/1209.2137.pdf and https://ayende.com/blog/199524-C/integer-compression-the-fastpfor-code</p> <p>Available implementations:</p> <ul> <li>C++: https://github.com/lemire/FastPFor</li> <li>Java: https://github.com/lemire/JavaFastPFOR</li> <li>C#: https://github.com/Genbox/CSharpFastPFOR</li> <li>Js/WebAssembly: Work in Progress (higher implementation complexity)</li> </ul>"},{"location":"encodings/#6-float-encodings","title":"6. Float encodings","text":""},{"location":"encodings/#61-adaptive-lossless-floating-point-compression-alp","title":"6.1 Adaptive Lossless floating-Point Compression (ALP)","text":"<p>See https://dl.acm.org/doi/pdf/10.1145/3626717 for a detailed explanation. ALP is a lossless floating-point compression technique that is used to compress the float values in MLT.</p> <p>Available implementations:</p> <ul> <li>C++: https://github.com/duckdb/duckdb/tree/16830ded9b4882b90f35c2d7e2d740547ae7d3fc/src/include/duckdb/storage/compression/alp</li> <li>Java: Work in Progress</li> <li>JS/WebAssembly: Work in Progress</li> </ul>"},{"location":"specification/","title":"Specification","text":"MapLibre Tile Specification <p>Note: This is a live specification that evolves continuously. Features marked as  are under active development and may change in future versions. Stable features are those without experimental tags.</p> <ul> <li>1. Basics</li> <li>2. File Layout<ul> <li>2.1 Metadata<ul> <li>2.1.1 Tileset Metadata</li> <li>2.1.2 Tile Metadata</li> </ul> </li> <li>2.2 Type system<ul> <li>2.2.1 Physical Types</li> <li>2.2.2 Logical Types</li> <li>2.2.3 Nested Fields Encoding</li> <li>2.2.4 RangeMap</li> </ul> </li> <li>2.3 Encoding Schemes</li> <li>2.4 FeatureTable Layout<ul> <li>2.4.1 ID Column</li> <li>2.4.2 Geometry Column</li> <li>2.4.3 Property Columns</li> </ul> </li> </ul> </li> <li>3. Example Layouts<ul> <li>3.1 Place layer</li> <li>3.2 LineString geometry with flat properties</li> <li>3.3 MultiPolygon with flat properties</li> <li>3.4 Vertex-scoped and feature-scoped properties</li> </ul> </li> <li>4. Sorting</li> <li>5. Encodings</li> <li>6. In-Memory Format</li> </ul>"},{"location":"specification/#1-basics","title":"1. Basics","text":"<p>MLT (MapLibre Tile) contains information about a specific geographic region - a tile. Each tile is a collection of <code>FeatureTables</code>, which are equivalent to Layers in the MVT specification.</p> <p>Each <code>FeatureTable</code> contains thematically grouped vector data, known as Features. Features in one FeatureTable share a common set of attribute columns (properties) and usually share the same geometry type (but not required to).</p> <p>The visual appearance of a tile on a map is usually controlled by MapLibre Style Specification, which specifies how the features in the FeatureTables are rendered.</p> <p>Each feature must have a <code>geometry</code> column, an optional <code>id</code> column, and optional property columns. The geometry column type is based on the OGC's Simple Feature Access Model (SFA) without the support for GeometryCollection types.</p> <p>The geometries are not restricted to one geometry type, but this is recommended for reasons of efficiency. As in MVT, the geometry coordinates are encoded as integers in a vector tile grid coordinates.</p> <p>Note</p> <p>\"column\", \"field\", and \"property\" are used interchangeably in this document.</p>"},{"location":"specification/#2-file-layout","title":"2. File Layout","text":"<p>A FeatureTable in the MLT specification is based on a tabular, column-oriented layout. It uses different lightweight compression schemes to efficiently encode the values of the columns. A FeatureTable consists of a optional <code>id</code> column, a mandatory <code>geometry</code> column and optional property columns. Because there is no tile header, <code>FeatureTable</code>s can be concatenated on the fly.</p> <p>A logical column is separated into several physical <code>streams</code> (sub-columns) inspired by the ORC file format which are stored next to each other. A stream is a sequence of values of a known length in a continuous chunk of memory, all having the same type. A stream has some additional metadata such as the size of the stream and the encoding type. For example, a nullable string property column can have a <code>present stream</code>, which indicates the presence of a value, a <code>length</code> stream, which describes the number of characters of every string, and a <code>data stream</code>, with the actual UTF-8 encoded string values.</p> <p>MLT distinguishes between the following type of streams:</p> <ul> <li>present:   Is used for a efficient encoding of sparse columns since it indicates the presence of a value base on a bit flag.   This stream can be omitted if the column is not declared as nullable in the <code>FieldMetadata</code>.</li> <li>data:   Stores the actual data of a column such as <code>boolean</code>, <code>int</code>, <code>float</code>, or <code>string</code> values of the feature properties.   Dictionary-encoded values, string values, or the coordinate values of a geometry column are stored in this type of stream.   In addition to the optional present stream, this is the only used stream type for fixed-sized data types such as <code>boolean</code>, <code>int</code>, and <code>float</code>.</li> <li>length:   Specifies the number of elements for variable-sized data types such as strings or list.</li> <li>offset:   Stores the offsets into a data stream when dictionary encoding is used such as for strings or vertices.</li> </ul> <p>This physical streams are further divided into logical streams that add additional semantics of how to interpret the data:</p> <p></p>"},{"location":"specification/#21-metadata","title":"2.1 Metadata","text":""},{"location":"specification/#211-tileset-metadata","title":"2.1.1 Tileset Metadata","text":"<p>Global metadata for the tileset is stored separately, in JSON format.</p> <p>The tileset metadata defines information for the full tileset is the equivalent to the TileJSON spec, which is commonly used in combination with MVT.</p> <p>By specifying the information once per tileset, the definition of redundant (shared) metadata per tile will be avoided, which can take some relevant space of the overall size on small tiles.</p>"},{"location":"specification/#212-tile-metadata","title":"2.1.2 Tile Metadata","text":"<p>Each <code>FeatureTable</code> is preceded by a <code>FeatureTableMetadata</code> describing it.</p> <p>A tile consists of any number of:</p> <ul> <li>The size of the <code>FeatureTableMetadata</code> to follow, varint-encoded</li> <li>The size of the <code>FeatureTable</code> to follow, varint-encoded</li> <li>One <code>FeatureTableMetadata</code></li> <li>One <code>FeatureTable</code></li> </ul> <p>The <code>FeatureTableMetadata</code> is described in detail below.</p> <p>Each <code>FeatureTableMetadata</code>/<code>FeatureTable</code> pair may contain one or more layers.  This allows the tile to be built by simple concatenation of separate results.</p> <p>Within a <code>FeatureTable</code>, additional metadata describes the structure of each part:</p> <ul> <li>FieldMetadata: contains information about the number of streams the field is divided and the vector type for efficient decoding into the in-memory format. Every Field (column) section is preceded by a <code>FieldMetadata</code> section.</li> <li>StreamMetdata: contains information about the Stream such as the used encoding schemes   and the number of values. Every Stream section is preceded by a <code>StreamMetadata</code> section.</li> </ul> <p>Since for every <code>Field</code>, a <code>FieldMetadata</code> section has to be present, even for fields which are not included in one specific tile, no <code>id</code> is needed. The absence of an entire field in a tile can be identified by a zero value for the number of streams. All integers in the metadata sections are <code>Varint</code>-encoded if u32 is used or bit-packed in case of an u8 data type.</p> <pre><code>---\ntitle: FeatureTableSchema\nconfig:\n  class:\n    hideEmptyMembersBox: true\n---\nclassDiagram\n    note for LogicalScalarType \"[EXPERIMENTAL]\"\n    note for ComplexColumn \"[EXPERIMENTAL]\"\n    note for ComplexField \"[EXPERIMENTAL]\"\n    note for ComplexType \"[EXPERIMENTAL]\"\n    note for LogicalComplexType \"[EXPERIMENTAL]\"\n    note for Field \"[EXPERIMENTAL]\"\n    note for ScalarField \"[EXPERIMENTAL]\"\n\n    %% ---------------- Tile ----------------\n    class Tile {\n      +LayerGroup[] groups\n    }\n\n    %% ---------------- LayerGroup ----------------\n    class LayerGroup {\n      +VarInt metadataSize\n      +TileMetadata metadata\n      +u8[] tileData\n    }\n\n    %% ---------------- TileMetadata ----------------\n    class TileMetadata {\n      +FeatureTable[] featureTables\n    }\n\n    %% ---------------- FeatureTable ----------------\n    class FeatureTable {\n      +String name\n      +VarInt columnCount\n      +Column[] columns\n    }\n\n    %% ---------------- Column ----------------\n    class Column {\n      +ColumnOptions options %% VarInt\n      +String name\n      +ScalarColumn scalarType %% oneof i.e., scalarType XOR complexType\n      +ComplexColumn complexType\n    }\n\n    %% ---------------- ScalarColumn ----------------\n    class ScalarColumn {\n      +ScalarColumnOptions options %% VarInt\n      +ScalarType physicalType %% oneof i.e., physicalType XOR logicalType\n      +LogicalScalarType logicalType\n    }\n\n    %% ---------------- ComplexColumn [EXPERIMENTAL] ----------------\n    class ComplexColumn {\n      +ComplexType physicalType %% oneof i.e., physicalType XOR logicalType\n      +LogicalComplexType logicalType\n      +VarInt childCount %% Present only if CHILD_TYPES is set in columnOptions\n      +Field[] children\n    }\n\n    %% ---------------- Field ----------------\n    class Field {\n      +FieldOptions options %% VarInt\n      +String name\n      +ScalarField scalarField %% oneof i.e., scalarField XOR complexField\n      +ComplexField complexField\n    }\n\n    %% ---------------- ScalarField ----------------\n    class ScalarField {\n      +ScalarType physicalType %% oneof i.e., physicalType XOR logicalType\n      +LogicalScalarType logicalType\n    }\n\n    %% ---------------- ComplexField [EXPERIMENTAL] ----------------\n    class ComplexField {\n      +ComplexType physicalType %% oneof i.e., physicalType XOR logicalType\n      +LogicalComplexType logicalType\n      +VarInt childCount %% Present only if CHILD_TYPES is set in columnOptions\n      +Field[] children\n    }\n\n    %% ---------------- String ------------------\n    class String {\n      +VarInt length\n      +u8 bytes[length] %% encoding is always UTF-8\n    }\n\n    %% ---------------- Enumerations ----------------\n    class ScalarType {\n      &lt;&lt;enumeration&gt;&gt;\n      BOOLEAN = 0\n      INT_8 = 1\n      UINT_8 = 2\n      INT_32 = 3\n      UINT_32 = 4\n      INT_64 = 5\n      UINT_64 = 6\n      FLOAT = 7\n      DOUBLE = 8\n      STRING = 9\n      INT_128 = 10\n      UINT_128 = 11\n    }\n\n    class LogicalScalarType {\n      &lt;&lt;enumeration&gt;&gt;\n      TIMESTAMP = 0\n      DATE = 1\n      JSON = 2\n    }\n\n    class ComplexType {\n      &lt;&lt;enumeration&gt;&gt;\n      VEC_2 = 0\n      VEC_3 = 1\n      GEOMETRY = 2\n      GEOMETRY_Z = 3\n      LIST = 4\n      MAP = 5\n      STRUCT = 6\n    }\n\n    class LogicalComplexType {\n      &lt;&lt;enumeration&gt;&gt;\n      BINARY = 0\n      RANGE_MAP = 1\n    }\n\n    class FieldOptions {\n      &lt;&lt;enumeration&gt;&gt;\n      NULLABLE = 1, %% Property is nullable\n      COMPLEX_TYPE = 2, %% A complexType follows if set, else a scalarType [EXPERIMENTAL]\n      LOGICAL_TYPE = 4, %% A logical type follows if set, else a physical type [EXPERIMENTAL]\n      CHILD_TYPES = 8, %% 1: Child types are present [EXPERIMENTAL]\n    }\n\n    class ColumnOptions {\n      &lt;&lt;enumeration&gt;&gt;\n      VERTEX_SCOPE = 16, %% Property is vertex-scope if set, else feature-scope\n    }\n\n    %% ---------------- Associations ----------------\n    FieldOptions &lt;|-- ColumnOptions\n    Tile --&gt; LayerGroup : groups\n    LayerGroup --&gt; TileMetadata : metadata\n    TileMetadata --&gt; FeatureTable : featureTables\n    FeatureTable --&gt; Column : columns\n    Column --&gt; ScalarColumn : scalarType\n    Column --&gt; ComplexColumn : complexType\n    ComplexColumn --&gt; Field : children\n    ComplexField --&gt; Field : children\n    Field --&gt; ComplexField : complexField\n    Field --&gt; ScalarField : scalarField</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom"},{"location":"specification/#22-type-system","title":"2.2 Type system","text":"<p>The types system of MLT is divided into physical and logical types. The physical types define the layout of the data in the storage format, while the logical types give additional semantics to the physical types. Based on this separation, the encoding and decoding of the data can be simplified. This reduces the complexity for implementing encoder and decoder as well allow the encodings to be reused.</p>"},{"location":"specification/#221-physical-types","title":"2.2.1 Physical Types","text":"<p>The physical types define the layout of the data in the storage format. Both scalar and complex types can be divided into fixed-size binaries and variable-size binaries. Variable-size binaries have an additional length stream which specifies the size of each element. All fixed-size binaries have the same bit (boolean) or byte width and therefore no additional length stream is used.</p> <p>Scalar Types</p> <p>Each scalar type has a specific encoding scheme which can be applied to the data stream.</p> DataType Logical Types Description Layout Boolean Fixed-Size Int8, UInt8, Int32, UInt32, Int64 , UInt64 Date (int32), Timestamp (int64) Fixed-Size Float, Double Fixed-Size String JSON UTF-8 encoded sequence of characters Variable-Size <p>Complex Types </p> <p>Complex types are composed of scalar types.</p> DataType Logical Types Description Layout List Binary (List) Variable-Size Map Map additional key stream -&gt; length, key, data streams Variable-Size Struct Vec2, Vec3 Geometry, GeometryZ Fixed-Size"},{"location":"specification/#222-logical-types","title":"2.2.2 Logical Types","text":"<p>Add additional semantics on top of the physical types. This had the advantage that encodings can be reused and implementation of encoders and decoders can be simplified.</p> Logical Type Physical Type Description Date Int32 number of days since Unix epoch Timestamp Int64 number of milliseconds since Unix epoch RangeMap Map, T&gt; for storing linear referencing information Binary List JSON String Geometry vec2 GeometryZ vec3"},{"location":"specification/#223-nested-fields-encoding","title":"2.2.3 Nested Fields Encoding","text":"<p>For nested properties such as structs and lists, a present/length pair encoding is selected over the widely used Dremel encoding, since it is simpler to implement and faster to decode into the in-memory format. Every nullable field, has an additional <code>present</code> stream. Every field that is a collection type, such as a list, has an additional <code>length</code> stream that specifies the length of the field. Like in ORC, the nested fields are flattened based on a pre-order traversal. In addition, nested fields can use a shared dictionary encoding, to share a common dictionary between the fields. This can be applied, for example, on localized values of the name:* columns of an OSM dataset that can be identical across fields. If a shared dictionary encoding is used for nested fields, all fields that use the shared dictionary must be grouped sequentially in the file and prefixed with the dictionary.</p>"},{"location":"specification/#224-rangemap","title":"2.2.4 RangeMap","text":"<p>RangeMaps are an efficient way to encode linear referencing information, as used for example in Overture Maps. RangesSets store the range values and data values in two separate streams. The min and max values for the ranges are stored as interleaved double values in a separate range stream.</p>"},{"location":"specification/#23-encoding-schemes","title":"2.3 Encoding Schemes","text":"<p>MLT uses different lightweight compression schemes for the space efficient storage and fast decoding of the data types. To further reduce the size of a column the encodings can be recursively cascaded (hybrid encodings) up to a certain level. For example the resulting integer columns of a dictionary encoding can be further compressed based on one of the Integer encoding schemes. The following encoding pool for specific data types was selected based on the analytics on the efficiency in terms of the compression ratio and decoding speed on test datasets such as the OpenMapTiles schema and Bing Maps based tilesets.</p> DataType Logical  Level Technique Physical Level Technique Description Boolean Boolean RLE Integer Plain, RLE, Delta, Delta-RLE SIMD-FastPFOR, Varint Float Plain, RLE, Dictionary, ALP String Plain, Dictionary, FSST Dictionary Geometry Plain, Dictionary, Morton-Dictionary <p>Note</p> <p><code>ALP</code>, <code>FSST</code>, and <code>FastPFOR</code> encodings are .</p> <p>Since SIMD-FastPFOR generally produces smaller data streams and is faster to decode, it should be preferred over Varint encoding. Varint encoding is mainly added to the encoding pool for compatibility reasons and it's simpler implementation compared to SIMD-FastPFOR. Varint encoding also can be more efficient when used in combination with heavyweight compression schemes like GZip.</p> <p>To find the best coding schemes for a specific data type from the coding pool, using a brute force approach by testing all available schemes with respect to the resulting column size would be too costly. The recommended approach improves the selection time by using the selection strategy described in the BTRBlocks paper:</p> <ul> <li>First, calculation of data metrics to early exclude encodings. For example if the average run length is less than 2,   RLE encoding is not a candidate for the encodings pool</li> <li>Second, use a sampling-based algorithm for choosing the best compression scheme out of the pool by taking randomly parts   of the data with a total size of 1% of the full data and apply the encoding schemes selected in step 1. Apply the encoding scheme   on the data which produces the smallest output</li> </ul>"},{"location":"specification/#24-featuretable-layout","title":"2.4 FeatureTable Layout","text":""},{"location":"specification/#241-id-column","title":"2.4.1 ID Column","text":"<p>No <code>id</code> column is mandatory.  If an identifier column is included, it should be u64 or a narrower integer type for compatibility with MVT. Narrow the column to u32, if possible, to enable the use of FastPfor128 encoding.</p>"},{"location":"specification/#242-geometry-column","title":"2.4.2 Geometry Column","text":"<p>The main idea is to use a structure of arrays (data-oriented design) layout for the geometries. The <code>x</code>, <code>y</code>, and optional <code>z</code> coordinates are stored interleaved in a <code>VertexBuffer</code> so that they can be efficiently processed on the CPU or even directly copied to GPU buffers. If the <code>z</code> coordinate is not relevant for rendering, it can be stored separately as an m-coordinate (see vertex-scoped properties).</p> <p>The information about the geometry of the features is separated in different streams and is partly inspired by the geoarrow specification. Using separate streams for describing the geometry of a feature enables a better optimization of the compression and faster processing. In addition, pre-tessellated polygon meshes can be stored directly in the file to avoid the time-consuming triangulation step.</p> <p>A geometry column can consist of the following streams:</p> Stream name Data type encoding mandatory GeometryType Byte see availabe integer encodings \u2713 NumGeometries UInt32 see availabe integer encodings \u2717 NumParts UInt32 see availabe integer encodings \u2717 NumRings UInt32 see availabe integer encodings \u2717 NumTriangles UInt32 see availabe integer encodings \u2717 IndexBuffer UInt32 see availabe integer encodings \u2717 VertexOffsets UInt32 see availabe integer encodings \u2717 VertexBuffer Int32 or Vertex[] Plain, Dictionary or Morton Dictionary \u2713 <p>Depending on the type of the geometry, the geometry column can have the following streams in addition to the <code>GeometryType</code> stream:</p> <ul> <li>Point: VertexBuffer</li> <li>LineString: NumParts, VertexBuffer</li> <li>Polygon: NumParts (Polygon), NumRings (LinearRing), VertexBuffer</li> <li>MultiPoint: NumGeometries, VertexBuffer</li> <li>MultiLineString: NumGeometries, NumParts (LineString), VertexBuffer</li> <li>MultiPolygon: NumGeometries, NumParts (Polygon), NumRings (LinearRing), VertexBuffer</li> </ul> <p>In addition, the geometry column can consist of an additional <code>VertexOffsets</code> stream when a Dictionary or Morton-Dictionary encoding is applied. If the geometries (mainly polygons) are stored in a tessellated/triangulated form for direct copying to a GPU Buffer, an additional <code>NumTriangles</code> and <code>IndexBuffer</code> must be provided.</p>"},{"location":"specification/#243-property-columns","title":"2.4.3 Property Columns","text":"<p>The properties of a feature are divided into <code>feature-scoped</code> and <code>vertex-scoped</code> properties. The values of feature-scoped properties are related to a specific Feature, which means there is one value in a property column per feature.</p> <p>The values of a vertex-scoped properties are related to each vertex, which means there is one value in a property column per vertex in the VertexBuffer. This allows to model what is known as M-coordinates in GIS applications. Vertex-scoped properties have to be grouped together and are placed before the feature-scoped properties in the FeatureTable. The scope of a property column is specified in the tileset metadata document based on the <code>ColumnScope</code> enum.</p> <p>A property column can have one of the above listed data types.</p>"},{"location":"specification/#3-example-layouts","title":"3. Example Layouts","text":"<p>In the following, examples for the layout of a <code>FeatureTable</code> in storage are illustrated. The following colors are used to highlight different kind of data:</p> <ul> <li>blue boxes: columns that have only logical character and are not persisted.   Based on the TileSet metadata the fields can be reconstructed from the streams.</li> <li>white boxes: metadata which describe the structure of the data. The metadata is divided into   FeatureTable, Stream (SM) and Feature (FM) metadata</li> <li>yellow boxes: streams which contains the actual data</li> </ul>"},{"location":"specification/#31-place-layer","title":"3.1 Place layer","text":"<p>Given a place layer with the following structure modeled as Json schema: </p> <p>For the given schema the place layer can have the following layout in a MLT tile when a dictionary for the <code>geometry</code> and <code>name</code> column is used. </p>"},{"location":"specification/#32-linestring-geometry-with-flat-properties","title":"3.2 LineString geometry with flat properties","text":"<p>Encoding of a <code>FeatureTable</code> with an <code>id</code> field, a <code>LineString</code> geometry field and the flat feature scoped properties class and subclass: </p>"},{"location":"specification/#33-multipolygon-with-flat-properties","title":"3.3 MultiPolygon with flat properties","text":"<p>Encoding of a <code>FeatureTable</code> with a <code>id</code> field, <code>MultiPolygon</code> geometry field and flat feature scoped property fields. Because vertex dictionary encoding is used a <code>VertexOffsets</code> stream is present: </p>"},{"location":"specification/#34-vertex-scoped-and-feature-scoped-properties","title":"3.4 Vertex-scoped and feature-scoped properties","text":"<p>Example layout for encoding of vertex-scoped and feature scoped properties. All vertex-scoped properties have to be grouped together and placed before the feature-scoped properties in the file. Since the <code>id</code> colum in this example is not <code>nullable</code>, the present stream can be omitted. </p>"},{"location":"specification/#4-sorting","title":"4. Sorting","text":"<p>Choosing the right column for sorting the features can have significant impact on the size of the <code>FeatureTable</code>. To take full advantage of the columnar layout, sorting is crucial. To test every layer for every possible sorting order of every column is too costly.</p>"},{"location":"specification/#5-encodings","title":"5. Encodings","text":"<p>The details of encodings are specified in a separate document.</p>"},{"location":"specification/#6-in-memory-format","title":"6. In-Memory Format","text":"<p>Note</p> <p>The in-memory format will be explained in more detail; the following is only a rough overview:</p> <p>The record-oriented, in-memory model (array of structures approach) used by the libraries that process the Mapbox Vector Tiles leads to a considerable overhead, such as the creation of a large number of small objects (per-object memory allocation), that place an additional load on the garbage collector in the browser.</p> <p>By using a columnar memory layout (data-oriented design), for the MLT in-memory format, we can overcome these issues and additionally take advantage of an improved cache utilization for subsequent access and fast SIMD instructions for the processing of the data. The MLT in-memory format incorporates and extends the ideas from the analytical in-memory formats Apache Arrow, Velox, and the DuckDB execution format and is tailored for the visualization use case. To be future-proof it is important that the file can be parallel processed on the GPU for the usage within a GPU compute shader.</p> <p>The main design goals of the MLT in-memory format are:</p> <ul> <li>Define a platform-agnostic representation to avoid the expensive materialization costs in particular for strings</li> <li>Enable advanced CPU throughput by optimizing the memory layout for cache locality and SIMD instructions</li> <li>Allow random (mainly constant time) access to all data, so it can also be parallel processed on the GPU (compute shader)</li> <li>Provide compressed data structure which can be directly processed without decoding</li> <li>Provide the geometries of a tile in a representation that can be (directly) loaded into GPU buffers with little or no additional processing</li> </ul> <p>The data are stored in continuous memory buffers, referred to as vectors, with additional metadata and an optional nullability bitmap for representing null values. The storage format contains a <code>VectorType</code> field in the metadata that tells the decoder which vector type to use for a specific filed. In order to enable random access to variable-sized data types such as strings or lists, an auxiliary buffer containing offset values will be utilized.</p> <p>The MLT in-memory format supports the following vectors:</p> <ul> <li>Flat Vectors</li> <li>Constant Vectors</li> <li>Sequence Vectors</li> <li>Dictionary Vectors</li> <li>FSST Dictionary Vectors </li> <li>Shared Dictionary Vectors </li> <li>Run-End Encoded (REE) Vectors</li> </ul> <p>Note</p> <p>Further evaluation is needed to determine if the latest research findings can be used to enable random access on delta encoded values as well</p> <p>In case a compressed vector can be used, this has the additional advantage that the conversion from the storage into in-memory format is basically a zero-copy operation.</p> <p>Following Apache Arrow's approach based on the Intel performance guide, we recommend that decoders should allocate memory on aligned addresses with a multiple of 64-bytes (if possible).</p>"}]}